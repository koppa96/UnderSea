/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.1.0 (NJsonSchema v10.0.19.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export class AccountsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAccount(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/Accounts/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAccount(_response);
        });
    }

    protected processGetAccount(response: AxiosResponse): Promise<UserInfo> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserInfo.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserInfo>(<any>null);
    }

    saveProvileImage(): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounts/me/image";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSaveProvileImage(_response);
        });
    }

    protected processSaveProvileImage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    changePassword(data: PasswordChangeData): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounts/me/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    getUsernames(): Promise<TargetInfo[]> {
        let url_ = this.baseUrl + "/api/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetUsernames(_response);
        });
    }

    protected processGetUsernames(response: AxiosResponse): Promise<TargetInfo[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TargetInfo.fromJS(item));
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TargetInfo[]>(<any>null);
    }

    createAccountAsnyc(data: RegisterData): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateAccountAsnyc(_response);
        });
    }

    protected processCreateAccountAsnyc(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    getRankedList(): Promise<RankInfo[]> {
        let url_ = this.baseUrl + "/api/Accounts/ranked";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetRankedList(_response);
        });
    }

    protected processGetRankedList(response: AxiosResponse): Promise<RankInfo[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RankInfo.fromJS(item));
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RankInfo[]>(<any>null);
    }
}

export class BuildingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getBuildings(): Promise<CreationInfo[]> {
        let url_ = this.baseUrl + "/api/Buildings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetBuildings(_response);
        });
    }

    protected processGetBuildings(response: AxiosResponse): Promise<CreationInfo[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreationInfo.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreationInfo[]>(<any>null);
    }

    startBuilding(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Buildings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processStartBuilding(_response);
        });
    }

    protected processStartBuilding(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CommandsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getCommands(): Promise<CommandInfo[]> {
        let url_ = this.baseUrl + "/api/Commands";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetCommands(_response);
        });
    }

    protected processGetCommands(response: AxiosResponse): Promise<CommandInfo[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommandInfo.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommandInfo[]>(<any>null);
    }

    attackTarget(command: CommandDetails): Promise<CommandInfo> {
        let url_ = this.baseUrl + "/api/Commands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAttackTarget(_response);
        });
    }

    protected processAttackTarget(response: AxiosResponse): Promise<CommandInfo> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommandInfo.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommandInfo>(<any>null);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Commands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    updateCommand(id: number, command: CommandDetails): Promise<CommandInfo> {
        let url_ = this.baseUrl + "/api/Commands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateCommand(_response);
        });
    }

    protected processUpdateCommand(response: AxiosResponse): Promise<CommandInfo> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommandInfo.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommandInfo>(<any>null);
    }
}

export class CountryClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getCurrentState(): Promise<CountryInfo> {
        let url_ = this.baseUrl + "/api/Country";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetCurrentState(_response);
        });
    }

    protected processGetCurrentState(response: AxiosResponse): Promise<CountryInfo> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CountryInfo.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CountryInfo>(<any>null);
    }
}

export class MaintenanceClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    endTurn(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Maintenance/endturn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "arraybuffer",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processEndTurn(_response);
        });
    }

    protected processEndTurn(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data]), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class ReportsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getBattleInfo(): Promise<CombatInfo[]> {
        let url_ = this.baseUrl + "/api/Reports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetBattleInfo(_response);
        });
    }

    protected processGetBattleInfo(response: AxiosResponse): Promise<CombatInfo[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CombatInfo.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CombatInfo[]>(<any>null);
    }

    setSeen(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Reports/seen/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSetSeen(_response);
        });
    }

    protected processSetSeen(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    deleteReport(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDeleteReport(_response);
        });
    }

    protected processDeleteReport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ResearchesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getResearches(): Promise<CreationInfo[]> {
        let url_ = this.baseUrl + "/api/Researches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetResearches(_response);
        });
    }

    protected processGetResearches(response: AxiosResponse): Promise<CreationInfo[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreationInfo.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreationInfo[]>(<any>null);
    }

    startResearch(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Researches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processStartResearch(_response);
        });
    }

    protected processStartResearch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UnitsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllUnits(): Promise<UnitInfo[]> {
        let url_ = this.baseUrl + "/api/Units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAllUnits(_response);
        });
    }

    protected processGetAllUnits(response: AxiosResponse): Promise<UnitInfo[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnitInfo.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnitInfo[]>(<any>null);
    }

    create(purchases: PurchaseDetails[]): Promise<UnitInfo[]> {
        let url_ = this.baseUrl + "/api/Units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(purchases);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<UnitInfo[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(UnitInfo.fromJS(item));
            }
            return result201;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnitInfo[]>(<any>null);
    }

    delete(id: number, count: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Units/{id}/{count}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined.");
        url_ = url_.replace("{count}", encodeURIComponent("" + count)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserInfo implements IUserInfo {
    username?: string | undefined;
    email?: string | undefined;
    profileImageUrl?: string | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.email = data["email"];
            this.profileImageUrl = data["profileImageUrl"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["email"] = this.email;
        data["profileImageUrl"] = this.profileImageUrl;
        return data; 
    }
}

export interface IUserInfo {
    username?: string | undefined;
    email?: string | undefined;
    profileImageUrl?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.status = data["status"];
            this.detail = data["detail"];
            this.instance = data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class PasswordChangeData implements IPasswordChangeData {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IPasswordChangeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldPassword = data["oldPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): PasswordChangeData {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordChangeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IPasswordChangeData {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class TargetInfo implements ITargetInfo {
    username?: string | undefined;
    countryId!: number;
    countryName?: string | undefined;

    constructor(data?: ITargetInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.countryId = data["countryId"];
            this.countryName = data["countryName"];
        }
    }

    static fromJS(data: any): TargetInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TargetInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data; 
    }
}

export interface ITargetInfo {
    username?: string | undefined;
    countryId: number;
    countryName?: string | undefined;
}

export class RegisterData implements IRegisterData {
    username?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: IRegisterData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.password = data["password"];
            this.email = data["email"];
            this.countryName = data["countryName"];
        }
    }

    static fromJS(data: any): RegisterData {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        data["countryName"] = this.countryName;
        return data; 
    }
}

export interface IRegisterData {
    username?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    countryName?: string | undefined;
}

export class RankInfo implements IRankInfo {
    name?: string | undefined;
    rank!: number;
    score?: string | undefined;

    constructor(data?: IRankInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.rank = data["rank"];
            this.score = data["score"];
        }
    }

    static fromJS(data: any): RankInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RankInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["rank"] = this.rank;
        data["score"] = this.score;
        return data; 
    }
}

export interface IRankInfo {
    name?: string | undefined;
    rank: number;
    score?: string | undefined;
}

export class CreationInfo implements ICreationInfo {
    id!: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    iconImageUrl?: string | undefined;
    cost!: number;

    constructor(data?: ICreationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.imageUrl = data["imageUrl"];
            this.iconImageUrl = data["iconImageUrl"];
            this.cost = data["cost"];
        }
    }

    static fromJS(data: any): CreationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CreationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["iconImageUrl"] = this.iconImageUrl;
        data["cost"] = this.cost;
        return data; 
    }
}

export interface ICreationInfo {
    id: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    iconImageUrl?: string | undefined;
    cost: number;
}

export class CommandInfo implements ICommandInfo {
    id!: number;
    targetCountryId!: number;
    targetCountryName?: string | undefined;
    units?: BriefUnitInfo[] | undefined;

    constructor(data?: ICommandInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.targetCountryId = data["targetCountryId"];
            this.targetCountryName = data["targetCountryName"];
            if (Array.isArray(data["units"])) {
                this.units = [] as any;
                for (let item of data["units"])
                    this.units!.push(BriefUnitInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommandInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CommandInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["targetCountryId"] = this.targetCountryId;
        data["targetCountryName"] = this.targetCountryName;
        if (Array.isArray(this.units)) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICommandInfo {
    id: number;
    targetCountryId: number;
    targetCountryName?: string | undefined;
    units?: BriefUnitInfo[] | undefined;
}

export class BriefUnitInfo implements IBriefUnitInfo {
    id!: number;
    name?: string | undefined;
    count!: number;
    imageUrl?: string | undefined;

    constructor(data?: IBriefUnitInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.count = data["count"];
            this.imageUrl = data["imageUrl"];
        }
    }

    static fromJS(data: any): BriefUnitInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BriefUnitInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["count"] = this.count;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IBriefUnitInfo {
    id: number;
    name?: string | undefined;
    count: number;
    imageUrl?: string | undefined;
}

export class CommandDetails implements ICommandDetails {
    targetCountryId!: number;
    units?: UnitDetails[] | undefined;

    constructor(data?: ICommandDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetCountryId = data["targetCountryId"];
            if (Array.isArray(data["units"])) {
                this.units = [] as any;
                for (let item of data["units"])
                    this.units!.push(UnitDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommandDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CommandDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetCountryId"] = this.targetCountryId;
        if (Array.isArray(this.units)) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICommandDetails {
    targetCountryId: number;
    units?: UnitDetails[] | undefined;
}

export class UnitDetails implements IUnitDetails {
    unitId!: number;
    amount!: number;

    constructor(data?: IUnitDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitId = data["unitId"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): UnitDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IUnitDetails {
    unitId: number;
    amount: number;
}

export class CountryInfo implements ICountryInfo {
    round!: number;
    rank!: number;
    armyInfo?: BriefUnitInfo[] | undefined;
    pearls!: number;
    corals!: number;
    pearlsPerRound!: number;
    coralsPerRound!: number;
    event?: EventInfo | undefined;
    unseenReports!: number;
    buildings?: BriefCreationInfo[] | undefined;
    researches?: BriefCreationInfo[] | undefined;

    constructor(data?: ICountryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.round = data["round"];
            this.rank = data["rank"];
            if (Array.isArray(data["armyInfo"])) {
                this.armyInfo = [] as any;
                for (let item of data["armyInfo"])
                    this.armyInfo!.push(BriefUnitInfo.fromJS(item));
            }
            this.pearls = data["pearls"];
            this.corals = data["corals"];
            this.pearlsPerRound = data["pearlsPerRound"];
            this.coralsPerRound = data["coralsPerRound"];
            this.event = data["event"] ? EventInfo.fromJS(data["event"]) : <any>undefined;
            this.unseenReports = data["unseenReports"];
            if (Array.isArray(data["buildings"])) {
                this.buildings = [] as any;
                for (let item of data["buildings"])
                    this.buildings!.push(BriefCreationInfo.fromJS(item));
            }
            if (Array.isArray(data["researches"])) {
                this.researches = [] as any;
                for (let item of data["researches"])
                    this.researches!.push(BriefCreationInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CountryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["round"] = this.round;
        data["rank"] = this.rank;
        if (Array.isArray(this.armyInfo)) {
            data["armyInfo"] = [];
            for (let item of this.armyInfo)
                data["armyInfo"].push(item.toJSON());
        }
        data["pearls"] = this.pearls;
        data["corals"] = this.corals;
        data["pearlsPerRound"] = this.pearlsPerRound;
        data["coralsPerRound"] = this.coralsPerRound;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["unseenReports"] = this.unseenReports;
        if (Array.isArray(this.buildings)) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        if (Array.isArray(this.researches)) {
            data["researches"] = [];
            for (let item of this.researches)
                data["researches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICountryInfo {
    round: number;
    rank: number;
    armyInfo?: BriefUnitInfo[] | undefined;
    pearls: number;
    corals: number;
    pearlsPerRound: number;
    coralsPerRound: number;
    event?: EventInfo | undefined;
    unseenReports: number;
    buildings?: BriefCreationInfo[] | undefined;
    researches?: BriefCreationInfo[] | undefined;
}

export class EventInfo implements IEventInfo {
    id!: number;
    name?: string | undefined;
    description?: string | undefined;
    flavourtext?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.flavourtext = data["flavourtext"];
            this.imageUrl = data["imageUrl"];
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["flavourtext"] = this.flavourtext;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IEventInfo {
    id: number;
    name?: string | undefined;
    description?: string | undefined;
    flavourtext?: string | undefined;
    imageUrl?: string | undefined;
}

export class BriefCreationInfo implements IBriefCreationInfo {
    id!: number;
    count!: number;
    inProgressCount!: number;
    imageUrl?: string | undefined;
    iconImageUrl?: string | undefined;

    constructor(data?: IBriefCreationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.count = data["count"];
            this.inProgressCount = data["inProgressCount"];
            this.imageUrl = data["imageUrl"];
            this.iconImageUrl = data["iconImageUrl"];
        }
    }

    static fromJS(data: any): BriefCreationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BriefCreationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["count"] = this.count;
        data["inProgressCount"] = this.inProgressCount;
        data["imageUrl"] = this.imageUrl;
        data["iconImageUrl"] = this.iconImageUrl;
        return data; 
    }
}

export interface IBriefCreationInfo {
    id: number;
    count: number;
    inProgressCount: number;
    imageUrl?: string | undefined;
    iconImageUrl?: string | undefined;
}

export class CombatInfo implements ICombatInfo {
    id!: number;
    round!: number;
    isAttack!: boolean;
    isWon!: boolean;
    enemyCountryId!: number;
    enemyCountryName?: string | undefined;
    yourUnits?: UnitInfo[] | undefined;
    enemyUnits?: UnitInfo[] | undefined;
    lostUnits?: UnitInfo[] | undefined;
    pealLoot!: number;
    coralLoot!: number;
    isSeen!: boolean;

    constructor(data?: ICombatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.round = data["round"];
            this.isAttack = data["isAttack"];
            this.isWon = data["isWon"];
            this.enemyCountryId = data["enemyCountryId"];
            this.enemyCountryName = data["enemyCountryName"];
            if (Array.isArray(data["yourUnits"])) {
                this.yourUnits = [] as any;
                for (let item of data["yourUnits"])
                    this.yourUnits!.push(UnitInfo.fromJS(item));
            }
            if (Array.isArray(data["enemyUnits"])) {
                this.enemyUnits = [] as any;
                for (let item of data["enemyUnits"])
                    this.enemyUnits!.push(UnitInfo.fromJS(item));
            }
            if (Array.isArray(data["lostUnits"])) {
                this.lostUnits = [] as any;
                for (let item of data["lostUnits"])
                    this.lostUnits!.push(UnitInfo.fromJS(item));
            }
            this.pealLoot = data["pealLoot"];
            this.coralLoot = data["coralLoot"];
            this.isSeen = data["isSeen"];
        }
    }

    static fromJS(data: any): CombatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CombatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["round"] = this.round;
        data["isAttack"] = this.isAttack;
        data["isWon"] = this.isWon;
        data["enemyCountryId"] = this.enemyCountryId;
        data["enemyCountryName"] = this.enemyCountryName;
        if (Array.isArray(this.yourUnits)) {
            data["yourUnits"] = [];
            for (let item of this.yourUnits)
                data["yourUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.enemyUnits)) {
            data["enemyUnits"] = [];
            for (let item of this.enemyUnits)
                data["enemyUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.lostUnits)) {
            data["lostUnits"] = [];
            for (let item of this.lostUnits)
                data["lostUnits"].push(item.toJSON());
        }
        data["pealLoot"] = this.pealLoot;
        data["coralLoot"] = this.coralLoot;
        data["isSeen"] = this.isSeen;
        return data; 
    }
}

export interface ICombatInfo {
    id: number;
    round: number;
    isAttack: boolean;
    isWon: boolean;
    enemyCountryId: number;
    enemyCountryName?: string | undefined;
    yourUnits?: UnitInfo[] | undefined;
    enemyUnits?: UnitInfo[] | undefined;
    lostUnits?: UnitInfo[] | undefined;
    pealLoot: number;
    coralLoot: number;
    isSeen: boolean;
}

export class UnitInfo implements IUnitInfo {
    id!: number;
    name?: string | undefined;
    imageUrl?: string | undefined;
    attackPower!: number;
    defensePower!: number;
    maintenancePearl!: number;
    maintenanceCoral!: number;
    costPearl!: number;

    constructor(data?: IUnitInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.imageUrl = data["imageUrl"];
            this.attackPower = data["attackPower"];
            this.defensePower = data["defensePower"];
            this.maintenancePearl = data["maintenancePearl"];
            this.maintenanceCoral = data["maintenanceCoral"];
            this.costPearl = data["costPearl"];
        }
    }

    static fromJS(data: any): UnitInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UnitInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUrl"] = this.imageUrl;
        data["attackPower"] = this.attackPower;
        data["defensePower"] = this.defensePower;
        data["maintenancePearl"] = this.maintenancePearl;
        data["maintenanceCoral"] = this.maintenanceCoral;
        data["costPearl"] = this.costPearl;
        return data; 
    }
}

export interface IUnitInfo {
    id: number;
    name?: string | undefined;
    imageUrl?: string | undefined;
    attackPower: number;
    defensePower: number;
    maintenancePearl: number;
    maintenanceCoral: number;
    costPearl: number;
}

export class PurchaseDetails implements IPurchaseDetails {
    unitId!: number;
    count!: number;

    constructor(data?: IPurchaseDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitId = data["unitId"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): PurchaseDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["count"] = this.count;
        return data; 
    }
}

export interface IPurchaseDetails {
    unitId: number;
    count: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}